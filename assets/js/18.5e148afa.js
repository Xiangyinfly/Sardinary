(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{451:function(t,l,v){t.exports=v.p+"assets/img/Untitled13.40bd7ab9.png"},452:function(t,l,v){t.exports=v.p+"assets/img/Untitled14.c67a327c.png"},453:function(t,l,v){t.exports=v.p+"assets/img/Untitled15.f33869cf.png"},454:function(t,l,v){t.exports=v.p+"assets/img/Untitled16.45520614.png"},455:function(t,l,v){t.exports=v.p+"assets/img/Untitled17.d32dd911.png"},456:function(t,l,v){t.exports=v.p+"assets/img/Untitled18.d005d31b.png"},457:function(t,l,v){t.exports=v.p+"assets/img/Untitled19.45c6dc57.png"},458:function(t,l,v){t.exports=v.p+"assets/img/Untitled20.dabc5ee4.png"},459:function(t,l,v){t.exports=v.p+"assets/img/Untitled21.8c5c2ab6.png"},460:function(t,l,v){t.exports=v.p+"assets/img/Untitled22.30a1aa60.png"},461:function(t,l,v){t.exports=v.p+"assets/img/Untitled23.152b2961.png"},462:function(t,l,v){t.exports=v.p+"assets/img/Untitled24.cea97118.png"},463:function(t,l,v){t.exports=v.p+"assets/img/Untitled25.538b682a.png"},568:function(t,l,v){"use strict";v.r(l);var i=v(2),_=Object(i.a)({},(function(){var t=this,l=t._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"定义"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),l("p",[t._v("Java内存模型，仅仅描述的是一组规定或规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时可用以及如何变成对另一个线程可用。")]),t._v(" "),l("h1",{attrs:{id:"三大特性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#三大特性"}},[t._v("#")]),t._v(" 三大特性")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("原子性")])]),t._v(" "),l("li",[l("p",[t._v("可见性")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("当一个线程修改了某个共享变量的值，其他线程能立即知道该变更")])]),t._v(" "),l("li",[l("p",[t._v("JMM规定所有变量都存储在主内存中")])]),t._v(" "),l("li",[l("p",[t._v("为防止脏读，每个线程都有自己的工作内存，线程自己的工作内存中保存的是该线程用到的变量的主内存的副本拷贝，线程对变量的所有操作都在工作内存中进行，而不是读写主内存中的变量")])]),t._v(" "),l("li",[l("p",[t._v("不同线程之间也不能访问对方的工作内存。线程之间变量值的传递均需要通过主内存完成")]),t._v(" "),l("p",[l("img",{attrs:{src:v(451),alt:"Untitled"}})])])])]),t._v(" "),l("li",[l("p",[t._v("有序性")]),t._v(" "),l("ul",[l("li",[t._v("指令的重排序\n"),l("ul",[l("li",[t._v("为了提升性能，编译器会对指令进行重新排序")]),t._v(" "),l("li",[t._v("JVM线程内部维持顺序化语义，只要最终结果和顺序化执行相同，指令的执行顺序可以和代码顺序不一致，这就是指令的重排序")]),t._v(" "),l("li",[t._v("优点：可以使指令更符合CPU执行特性，提高机器性能")]),t._v(" "),l("li",[t._v("缺点：保证串行语义相同，但是不保证多线程间的语义一直，从而产生脏读")])])])])])]),t._v(" "),l("h1",{attrs:{id:"多线程对变量的读写过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程对变量的读写过程"}},[t._v("#")]),t._v(" 多线程对变量的读写过程")]),t._v(" "),l("ul",[l("li",[t._v("定义的所有线程之间的共享变量存储在主内存中")]),t._v(" "),l("li",[t._v("每个线程有一个私有的工作内存，存储了用来读写的副本")]),t._v(" "),l("li",[t._v("线程对共享变量所有操作先在工作内存中进行后写回主内存，不能直接从主内存中写")]),t._v(" "),l("li",[t._v("不同线程之间也不能访问对方的工作内存中的变量。线程之间变量值的传递均需要通过主内存完成")])]),t._v(" "),l("p",[l("img",{attrs:{src:v(452),alt:"Untitled"}})]),t._v(" "),l("h1",{attrs:{id:"先行发生原则-happens-before"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#先行发生原则-happens-before"}},[t._v("#")]),t._v(" 先行发生原则 happens-before")]),t._v(" "),l("ul",[l("li",[t._v("JMM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间存在先行发生原则")]),t._v(" "),l("li",[t._v("解决并发环境下两个操作是否可能存在冲突的问题")]),t._v(" "),l("li",[t._v("原则\n"),l("ul",[l("li",[t._v("如果一个操作happens-before另一个操作，那么第一个的执行结果将对第二个可见，而且第一个的执行顺序在第二个之前")]),t._v(" "),l("li",[t._v("两个操作存在happens-before关系，并不意味着一定按照happens-before原则制定的顺序来执行。如果重排序后的执行结果与按照happens-before来执行的结果一致，那么这种重排序并不非法。")])])]),t._v(" "),l("li",[t._v("八条规则\n"),l("ul",[l("li",[t._v("次序规则\n"),l("ul",[l("li",[t._v("一个线程内，按照代码顺序，写在前面的操作先行发生在写在后面的操作")]),t._v(" "),l("li",[t._v("前面一个操作的结果可以被后续操作获取")])])]),t._v(" "),l("li",[t._v("锁定规则\n"),l("ul",[l("li",[t._v("unlock操作先行发生于后面对同一个锁的lock操作。后面指的是时间上的先后")])])]),t._v(" "),l("li",[t._v("volatile变量规则\n"),l("ul",[l("li",[t._v("对一个volatile变量的写操作先行发生于后面对这个变量的读操作。")]),t._v(" "),l("li",[t._v("前面的写对后面的读是可见的。后面指的是时间上的先后")])])]),t._v(" "),l("li",[t._v("传递规则\n"),l("ul",[l("li",[t._v("a先于b，b先于c → c先于c")])])]),t._v(" "),l("li",[t._v("线程启动规则\n"),l("ul",[l("li",[t._v("Thread对象的start方法先行发生于此线程的每一个动作")])])]),t._v(" "),l("li",[t._v("线程中断规则\n"),l("ul",[l("li",[t._v("对线程interrupt方法的调用 先行发生于 被中断线程的代码检测到中断事件的发生")]),t._v(" "),l("li",[t._v("可以通过Thread.interrupted()方法检测是否发生中断")]),t._v(" "),l("li",[t._v("要先调用interrupt方法设置中断标识位，才能检测到中断发生")])])]),t._v(" "),l("li",[t._v("线程终止规则\n"),l("ul",[l("li",[t._v("线程中的所有操作都先行发生于对此线程的终止检测。即线程会完成所有业务之后才会进行终止检测")]),t._v(" "),l("li",[t._v("可以通过isAlive方法检测线程是否已经终止")])])]),t._v(" "),l("li",[t._v("对象终结规则 Finalizer Rule\n"),l("ul",[l("li",[t._v("一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize方法的开始")])])])])]),t._v(" "),l("li",[t._v("happens-before的语义本质上是一种可见性")]),t._v(" "),l("li",[t._v("设计分为两部分\n"),l("ul",[l("li",[t._v("对程序员提供规则，阐述了一个强内存模型")]),t._v(" "),l("li",[t._v("提高JVM性能，JMM在不影响程序执行结果前提下对其不做要求，允许优化重排序")])])])]),t._v(" "),l("h1",{attrs:{id:"volatile"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" Volatile")]),t._v(" "),l("h2",{attrs:{id:"特点"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),l("ul",[l("li",[t._v("可见性")]),t._v(" "),l("li",[t._v("有序性。有排序要求，有时候禁止重排")]),t._v(" "),l("li",[t._v("没有原子性")])]),t._v(" "),l("h2",{attrs:{id:"volatile的内存语义"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#volatile的内存语义"}},[t._v("#")]),t._v(" Volatile的内存语义")]),t._v(" "),l("ul",[l("li",[t._v("写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中")]),t._v(" "),l("li",[t._v("读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量")]),t._v(" "),l("li",[t._v("所以volatile的写内存语义是直接刷新到主内存中，读内存语义是直接从主内存中读")])]),t._v(" "),l("aside",[t._v("\n🤔 为什么volatile可以保证可见性和有序性？\n")]),t._v(" "),l("h2",{attrs:{id:"内存屏障"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[t._v("#")]),t._v(" 内存屏障")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点后的操作")])]),t._v(" "),l("li",[l("p",[t._v("是一种JVM指令，避免了代码重排序")])]),t._v(" "),l("li",[l("p",[t._v("JMM的点重排规则会要求java编译器在生成JVM指令时插入特定的内存屏障指令，因此volatile实现了可见性和有序性（禁重排），但是无法保证原子性")])]),t._v(" "),l("li",[l("p",[t._v("体现")]),t._v(" "),l("ul",[l("li",[t._v("屏障之前的所有写操作都要写会主内存")]),t._v(" "),l("li",[t._v("屏障之后的所有读操作都能获得屏障之前的所有写操作的最新结果（实现了可见性）")]),t._v(" "),l("li",[t._v("因此重排序时，不允许把屏障之后的指令重排序到屏障之前。对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读。也叫写后读")])])]),t._v(" "),l("li",[l("p",[t._v("分类")]),t._v(" "),l("ul",[l("li",[t._v("读屏障 Load Barrier\n"),l("ul",[l("li",[t._v("在读指令前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存获取最新数据")])])]),t._v(" "),l("li",[t._v("写屏障 Store Barrier\n"),l("ul",[l("li",[t._v("在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中")])])])])]),t._v(" "),l("li",[l("p",[t._v("volatile变量规则")]),t._v(" "),l("p",[l("img",{attrs:{src:v(453),alt:"Untitled"}})])]),t._v(" "),l("li",[l("p",[t._v("内存屏障插入策略的四种规则")]),t._v(" "),l("p",[l("img",{attrs:{src:v(454),alt:"Untitled"}})]),t._v(" "),l("ul",[l("li",[l("p",[t._v("读屏障：在每个volatile读操作之后插入一个LoadLoad屏障和一个LoadStore屏障")]),t._v(" "),l("ul",[l("li",[t._v("由于第一个是volatile读，第二个是啥都不能重排序，因此要插入LoadLoad和LoadStore两个屏障来保证不能重排序，即四种规则图中蓝色圈")])]),t._v(" "),l("p",[l("img",{attrs:{src:v(455),alt:"Untitled"}})])]),t._v(" "),l("li",[l("p",[t._v("写屏障：在每个volatile写操作之前插入一个StoreStore屏障，在每个volatile写操作之后插入一个StoreLoad屏障")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("写操作之前插入StoreStore：")]),t._v(" "),l("p",[t._v("保证第二个是volatile写的时候，第一个是任何写都不能重排序，即四种规则图中红色圈")]),t._v(" "),l("p",[t._v("那第一个是volatile读的时候呢，怎么保证不重排序？答：如果前面是volatile读的，会在后面加LoadStore来保证。所以这时候的保证是由volatile读加的屏障来保证的。即四种规则图中蓝色红色圈交叉的部分")])]),t._v(" "),l("li",[l("p",[t._v("写操作之后插入StoreLoad：")]),t._v(" "),l("p",[t._v("保证第一个是volatile写，第二个是volatile读的时候不能重排序，即四种规则图中粉色圈")])])]),t._v(" "),l("p",[l("img",{attrs:{src:v(456),alt:"Untitled"}})])])])])]),t._v(" "),l("h2",{attrs:{id:"volatile特性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#volatile特性"}},[t._v("#")]),t._v(" Volatile特性")]),t._v(" "),l("h3",{attrs:{id:"保证可见性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#保证可见性"}},[t._v("#")]),t._v(" 保证可见性")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("由于Volatile具备可见性，JVM保证主内存中加载到工作内存中的值是最新的，也仅是数据加载时是最新的")])]),t._v(" "),l("li",[l("p",[t._v("Volatile变量的读写过程")]),t._v(" "),l("p",[l("img",{attrs:{src:v(457),alt:"Untitled"}})]),t._v(" "),l("p",[l("img",{attrs:{src:v(458),alt:"Untitled"}})]),t._v(" "),l("p",[l("img",{attrs:{src:v(459),alt:"Untitled"}})])])]),t._v(" "),l("h3",{attrs:{id:"没有原子性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#没有原子性"}},[t._v("#")]),t._v(" 没有原子性")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("Volatile的复合操作不具有原子性")])]),t._v(" "),l("li",[l("p",[t._v("因此Volatile变量不适合参与到依赖当前值的运算")])]),t._v(" "),l("li",[l("p",[t._v("内存工作过程")]),t._v(" "),l("p",[l("img",{attrs:{src:v(460),alt:"Untitled"}})]),t._v(" "),l("ul",[l("li",[t._v("例如多个线程同时对一个Volatile变量i执行多次i++\n"),l("ul",[l("li",[t._v("线程a和b同时将数据读取到本地内存")]),t._v(" "),l("li",[t._v("a较快的进行数据加载、计算、赋值，而b较慢")]),t._v(" "),l("li",[t._v("b在执行加载、计算、赋值这三步的时候，a已经执行完毕并将数据写入主内存")]),t._v(" "),l("li",[t._v("此时出现主内存数据更新，则a工作内存中数据被作废，去读取最新值，出现了写丢失问题，即浪费了一次i++的执行")]),t._v(" "),l("li",[t._v("因此最终i的增加数小于设定的理论增加数")])])]),t._v(" "),l("li",[t._v("会导致各线程私有内存和主内存中变量不同步，必须要加锁同步")])])])]),t._v(" "),l("h3",{attrs:{id:"指令禁重排"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#指令禁重排"}},[t._v("#")]),t._v(" 指令禁重排")]),t._v(" "),l("ul",[l("li",[t._v("程序语句的先后顺序存在依赖关系，禁止重排序")]),t._v(" "),l("li",[t._v("插入"),l("RouterLink",{attrs:{to:"/blogs/JUC/JMM与Volatile 69343b87a173430e83b429f51986d7e3.html"}},[t._v("内存屏障")])],1)]),t._v(" "),l("h2",{attrs:{id:"volatile使用"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#volatile使用"}},[t._v("#")]),t._v(" Volatile使用")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("单一赋值可以，但是含复合运算的赋值不可以，如i++")])]),t._v(" "),l("li",[l("p",[t._v("作为状态标识，判断业务是否结束")])]),t._v(" "),l("li",[l("p",[t._v("开销较低的读写锁策略")]),t._v(" "),l("p",[l("img",{attrs:{src:v(461),alt:"Untitled"}})])]),t._v(" "),l("li",[l("p",[t._v("DCL双端锁的发布")]),t._v(" "),l("p",[l("img",{attrs:{src:v(462),alt:"Untitled"}})]),t._v(" "),l("ul",[l("li",[t._v("多线程环境下，在隐患处，可能会由于2、3重排导致其他线程得到的是null而不是完成初始化的对象。")]),t._v(" "),l("li",[t._v("可以通过加volatile解决")])]),t._v(" "),l("p",[l("img",{attrs:{src:v(463),alt:"Untitled"}})])])]),t._v(" "),l("h2",{attrs:{id:"哪些地方用到了volatile"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#哪些地方用到了volatile"}},[t._v("#")]),t._v(" 哪些地方用到了Volatile？")]),t._v(" "),l("ul",[l("li",[t._v("双端锁")]),t._v(" "),l("li",[l("RouterLink",{attrs:{to:"/blogs/JUC/CAS和Atomic类 532499754a134662add3f629b929a7e6.html"}},[t._v("对象属性修改原子类")])],1)])])}),[],!1,null,null,null);l.default=_.exports}}]);