(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{497:function(t,a,s){t.exports=s.p+"assets/img/Untitled14.3c635af6.png"},498:function(t,a,s){t.exports=s.p+"assets/img/Untitled15.ab48a5bb.png"},499:function(t,a,s){t.exports=s.p+"assets/img/Untitled16.2611fa8e.png"},500:function(t,a,s){t.exports=s.p+"assets/img/Untitled17.2661a331.png"},501:function(t,a,s){t.exports=s.p+"assets/img/Untitled18.7cf7a4b6.png"},502:function(t,a,s){t.exports=s.p+"assets/img/Untitled19.e38a6040.png"},503:function(t,a,s){t.exports=s.p+"assets/img/Untitled20.51b1e35f.png"},504:function(t,a,s){t.exports=s.p+"assets/img/Untitled21.437a5cb5.png"},505:function(t,a,s){t.exports=s.p+"assets/img/Untitled22.d4d95f97.png"},588:function(t,a,s){"use strict";s.r(a);var r=s(2),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("双写只能做到最终一致性，不能做到强一致性")]),t._v(" "),a("h2",{attrs:{id:"双写一致性标准"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双写一致性标准"}},[t._v("#")]),t._v(" 双写一致性标准")]),t._v(" "),a("p",[t._v("一般以mysql中的数据作为标准")]),t._v(" "),a("h2",{attrs:{id:"缓存操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存操作"}},[t._v("#")]),t._v(" 缓存操作")]),t._v(" "),a("p",[a("img",{attrs:{src:s(497),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"双检加锁策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双检加锁策略"}},[t._v("#")]),t._v(" 双检加锁策略")]),t._v(" "),a("p",[t._v("查询时redis有mysql无，如何保证双写一致性？如何避免缓存击穿？")]),t._v(" "),a("p",[t._v("采用双检加锁策略")]),t._v(" "),a("p",[a("img",{attrs:{src:s(498),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"缓存更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存更新策略"}},[t._v("#")]),t._v(" 缓存更新策略")]),t._v(" "),a("h3",{attrs:{id:"更新数据库并且更新缓存的策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新数据库并且更新缓存的策略"}},[t._v("#")]),t._v(" 更新数据库并且更新缓存的策略")]),t._v(" "),a("p",[t._v("两个线程同时更新可能出现先更新数据库的线程后更新了redis的情况，导致redis中为脏数据。")]),t._v(" "),a("h3",{attrs:{id:"更新数据库并且删除缓存的策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新数据库并且删除缓存的策略"}},[t._v("#")]),t._v(" 更新数据库并且删除缓存的策略")]),t._v(" "),a("p",[a("img",{attrs:{src:s(499),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"延时双删"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延时双删"}},[t._v("#")]),t._v(" 延时双删")]),t._v(" "),a("p",[a("img",{attrs:{src:s(500),alt:"Untitled"}})]),t._v(" "),a("h3",{attrs:{id:"删除休眠多久"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除休眠多久"}},[t._v("#")]),t._v(" 删除休眠多久？")]),t._v(" "),a("p",[t._v("线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。")]),t._v(" "),a("p",[t._v("第一种方法：")]),t._v(" "),a("p",[t._v("在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，自行评估自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上加百毫秒即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。")]),t._v(" "),a("p",[t._v("第二种方法：")]),t._v(" "),a("p",[t._v("新启动一个后台监控程序，比如后面要讲解的WatchDog监控程序，会加时。")]),t._v(" "),a("h3",{attrs:{id:"这种同步淘汰策略导致吞吐量降低怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这种同步淘汰策略导致吞吐量降低怎么办"}},[t._v("#")]),t._v(" 这种同步淘汰策略导致吞吐量降低怎么办？")]),t._v(" "),a("p",[t._v("将第二次删除作为异步的")]),t._v(" "),a("p",[a("img",{attrs:{src:s(501),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"成熟方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#成熟方案"}},[t._v("#")]),t._v(" 成熟方案")]),t._v(" "),a("p",[t._v("mysql更新后立刻同步到redis")]),t._v(" "),a("p",[a("img",{attrs:{src:s(502),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"canal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canal"}},[t._v("#")]),t._v(" Canal")]),t._v(" "),a("p",[a("img",{attrs:{src:s(503),alt:"Untitled"}})]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("mysql主从复制原理")]),t._v(" "),a("p",[a("img",{attrs:{src:s(504),alt:"Untitled"}})]),t._v(" "),a("p",[t._v("canal原理")]),t._v(" "),a("p",[a("img",{attrs:{src:s(505),alt:"Untitled"}})]),t._v(" "),a("h2",{attrs:{id:"文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文章"}},[t._v("#")]),t._v(" 文章")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/blogs/Redis/缓存最终一致性的解决方案 2ed715404f5845cb8f3436f44eb96dfc.html"}},[a("strong",[t._v("缓存最终一致性的解决方案")])])],1),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/blogs/Redis/如何保证缓存和数据库一致性 cb199a04ad8a4ccda202d3f0615a1181.html"}},[t._v("如何保证缓存和数据库一致性")])],1)])}),[],!1,null,null,null);a.default=e.exports}}]);