(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{493:function(t,e,s){t.exports=s.p+"assets/img/Untitled.e424abae.png"},494:function(t,e,s){t.exports=s.p+"assets/img/Untitled1.73af63e8.png"},495:function(t,e,s){t.exports=s.p+"assets/img/Untitled2.294f036d.png"},496:function(t,e,s){t.exports=s.p+"assets/img/Untitled3.c6640f50.png"},585:function(t,e,s){"use strict";s.r(e);var _=s(2),v=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("原文：\n"),e("a",{attrs:{href:"https://www.cnblogs.com/rjzheng/p/11430592.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("【原创】为什么Redis集群有16384个槽 - 孤独烟 - 博客园"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("作者原版回答如下:")]),t._v(" "),e("p",[e("code",[t._v("https://github.com/antirez/redis/issues/2576")])]),t._v(" "),e("p",[t._v("The reason is:")]),t._v(" "),e("ul",[e("li",[t._v("Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.")]),t._v(" "),e("li",[t._v("At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.")])]),t._v(" "),e("p",[t._v("So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots/N bits set that is a large percentage of bits set.")]),t._v(" "),e("p",[t._v("因此，能看懂上面那段话的读者。这篇文章不用看了，因为作者讲的很清楚了。本文只是对上面那段话做一些解释而已。")]),t._v(" "),e("h2",{attrs:{id:"正文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" "),e("strong",[t._v("正文")])]),t._v(" "),e("h3",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" "),e("strong",[t._v("基础")])]),t._v(" "),e("p",[t._v("我们回忆一下"),e("code",[t._v("Redis Cluster")]),t._v("的工作原理！")]),t._v(" "),e("p",[t._v("这里要先将节点握手讲清楚。我们让两个redis节点之间进行通信的时候，需要在客户端执行下面一个命令")]),t._v(" "),e("div",{staticClass:"language-makefile extra-class"},[e("pre",{pre:!0,attrs:{class:"language-makefile"}},[e("code",[e("span",{pre:!0,attrs:{class:"token target symbol"}},[t._v("127.0.0.1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("7000>cluster meet 127.0.0.1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("7001\n\n")])])]),e("p",[t._v("如下图所示")]),t._v(" "),e("p",[e("img",{attrs:{src:s(493),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("意思很简单，让7000节点和7001节点知道彼此存在！")]),t._v(" "),e("p",[t._v("在握手成功后，连个节点之间会"),e("strong",[t._v("定期")]),t._v("发送ping/pong消息，交换"),e("strong",[t._v("数据信息")]),t._v("，如下图所示。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(494),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("在这里，我们需要关注三个重点。")]),t._v(" "),e("ul",[e("li",[t._v("(1)交换什么数据信息")]),t._v(" "),e("li",[t._v("(2)数据信息究竟多大")]),t._v(" "),e("li",[t._v("(3)定期的频率什么样")])]),t._v(" "),e("p",[e("em",[t._v("到底在交换什么数据信息？")])]),t._v(" "),e("p",[t._v("交换的数据信息，由消息体和消息头组成。")]),t._v(" "),e("p",[t._v("消息体无外乎是一些节点标识啊，IP啊，端口号啊，发送时间啊。这与本文关系不是太大，我不细说。")]),t._v(" "),e("p",[t._v("我们来看消息头，结构如下")]),t._v(" "),e("p",[e("img",{attrs:{src:s(495),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("注意看红框的内容，type表示消息类型。")]),t._v(" "),e("p",[t._v("另外，消息头里面有个myslots的char数组，长度为16383/8，这其实是一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。")]),t._v(" "),e("p",[e("em",[t._v("到底数据信息究竟多大？")])]),t._v(" "),e("p",[t._v("在消息头中，最占空间的是"),e("code",[t._v("myslots[CLUSTER_SLOTS/8]")]),t._v("。这块的大小是:")]),t._v(" "),e("p",[e("code",[t._v("16384÷8÷1024=2kb")])]),t._v(" "),e("p",[t._v("那在消息体中，会携带一定数量的其他节点信息用于交换。")]),t._v(" "),e("p",[t._v("那这个其他节点的信息，到底是几个节点的信息呢？")]),t._v(" "),e("p",[t._v("约为集群总节点数量的1/10，至少携带3个节点的信息。")]),t._v(" "),e("p",[t._v("**这里的重点是:**节点数量越多，消息体内容越大。")]),t._v(" "),e("p",[t._v("消息体大小是10个节点的状态信息约1kb。")]),t._v(" "),e("p",[e("em",[t._v("那定期的频率是什么样的？")])]),t._v(" "),e("p",[t._v("redis集群内节点，每秒都在发ping消息。规律如下")]),t._v(" "),e("ul",[e("li",[t._v("(1)每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息")]),t._v(" "),e("li",[t._v("(2)每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 则立刻发送ping消息")])]),t._v(" "),e("p",[t._v("因此，每秒单节点发出ping消息数量为")]),t._v(" "),e("p",[e("code",[t._v("数量=1+10*num（node.pong_received>cluster_node_timeout/2）")])]),t._v(" "),e("p",[t._v("那大致带宽损耗如下所示，图片来自《Redis运维与实现》")]),t._v(" "),e("p",[e("img",{attrs:{src:s(496),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("讲完基础知识以后，我们可以来看作者的回答了。")]),t._v(" "),e("h3",{attrs:{id:"回答"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回答"}},[t._v("#")]),t._v(" "),e("strong",[t._v("回答")])]),t._v(" "),e("p",[t._v("(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。")]),t._v(" "),e("p",[t._v("如上所述，在消息头中，最占空间的是"),e("code",[t._v("myslots[CLUSTER_SLOTS/8]")]),t._v("。")]),t._v(" "),e("p",[t._v("当槽位为65536时，这块的大小是:")]),t._v(" "),e("p",[e("code",[t._v("65536÷8÷1024=8kb")])]),t._v(" "),e("p",[t._v("因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。")]),t._v(" "),e("p",[t._v("(2)redis的集群主节点数量基本不可能超过1000个。")]),t._v(" "),e("p",[t._v("如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。")]),t._v(" "),e("p",[t._v("那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。")]),t._v(" "),e("p",[t._v("(3)槽位越小，节点少的情况下，压缩比高")]),t._v(" "),e("p",[t._v("Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。")]),t._v(" "),e("p",[t._v("如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。")]),t._v(" "),e("p",[e("code",[t._v("ps")]),t._v("：文件压缩率指的是，文件压缩前后的大小比。")]),t._v(" "),e("p",[t._v("综上所述，作者决定取16384个槽，不多不少，刚刚好！")])])}),[],!1,null,null,null);e.default=v.exports}}]);