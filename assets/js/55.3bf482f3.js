(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{486:function(t,v,_){t.exports=_.p+"assets/img/Untitled25.0e050baf.png"},581:function(t,v,_){"use strict";_.r(v);var e=_(2),s=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("该方案也是基于（set 加锁、Lua 脚本解锁）进行改良的，所以redis之父antirez 只描述了差异的地方，大致方案如下。")]),t._v(" "),v("p",[t._v("假设我们有N个Redis主节点，例如 N = 5这些节点是完全独立的，我们不使用复制或任何其他隐式协调系统，")]),t._v(" "),v("p",[t._v("为了取到锁客户端执行以下操作：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("1")]),t._v(" "),v("th",[t._v("获取当前时间，以毫秒为单位；")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("2")]),t._v(" "),v("td",[t._v("依次尝试从5个实例，使用相同的 key 和随机值（例如 UUID）获取锁。当向Redis 请求获取锁时，客户端应该设置一个超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态。如果一个实例不可用，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁；")])]),t._v(" "),v("tr",[v("td",[t._v("3")]),t._v(" "),v("td",[t._v("客户端通过当前时间减去步骤 1 记录的时间来计算获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且获取锁使用的时间小于锁失效时间时，锁才算获取成功；")])]),t._v(" "),v("tr",[v("td",[t._v("4")]),t._v(" "),v("td",[t._v("如果取到了锁，其真正有效时间等于初始有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。")])]),t._v(" "),v("tr",[v("td",[t._v("5")]),t._v(" "),v("td",[t._v("如果由于某些原因未能获得锁（无法在至少 N/2 + 1 个 Redis 实例获取锁、或获取锁的时间超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。")])])])]),t._v(" "),v("p",[t._v("该方案为了解决数据不一致的问题，直接舍弃了异步复制只使用 master 节点，同时由于舍弃了 slave，为了保证可用性，引入了 N 个节点，官方建议是 5。阳哥本次教学演示用3台实例来做说明。")]),t._v(" "),v("p",[t._v("客户端只有在满足下面的这两个条件时，才能认为是加锁成功。")]),t._v(" "),v("p",[t._v("条件1：客户端从超过半数（大于等于N/2+1）的Redis实例上成功获取到了锁；")]),t._v(" "),v("p",[t._v("条件2：客户端获取锁的总耗时没有超过锁的有效时间。")]),t._v(" "),v("p",[v("img",{attrs:{src:_(486),alt:"Untitled"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);