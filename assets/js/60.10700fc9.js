(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{570:function(l,n,i){"use strict";i.r(n);var t=i(2),o=Object(t.a)({},(function(){var l=this,n=l._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[n("ul",[n("li",[l._v("一把锁：synchronized（后面细讲）")]),l._v(" "),n("li",[l._v("两个并：\n"),n("ul",[n("li",[l._v("并发（concurrent）：是在同一实体上的多个事件，是在一台机器上“同时”处理多个任务，同一时刻，其实是只有一个事情再发生。")]),l._v(" "),n("li",[l._v("并行（parallel）：是在不同实体上的多个事件，是在多台处理器上同时处理多个任务，同一时刻，大家都在做事情，你做你的，我做我的，各干各的。")])])]),l._v(" "),n("li",[l._v("三个程：\n"),n("ul",[n("li",[l._v("进程：在系统中运行的一个应用程序，每个进程都有它自己的内存空间和系统资源")]),l._v(" "),n("li",[l._v("线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。")]),l._v(" "),n("li",[l._v("管程：Monitor（锁），也就是我们平时所说的锁。Monitor其实是一种同步机制，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，底层由C++语言实现。")])])]),l._v(" "),n("li",[l._v("线程类型\n"),n("ul",[n("li",[l._v("用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。")]),l._v(" "),n("li",[l._v("守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作。")])])])])])}),[],!1,null,null,null);n.default=o.exports}}]);