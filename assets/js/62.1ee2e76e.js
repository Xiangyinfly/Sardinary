(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{579:function(a,s,t){"use strict";t.r(s);var e=t(2),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"限制keys-flushdb-flushall等危险命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#限制keys-flushdb-flushall等危险命令"}},[a._v("#")]),a._v(" 限制keys */flushdb/flushall等危险命令")]),a._v(" "),s("p",[a._v("在conf文件的security项中配置禁用这些命令")]),a._v(" "),s("p",[a._v("如果AOF或RDB中包含了需要禁用的命令，Redis会启动不起来，需要删除AOF以及RDB文件")]),a._v(" "),s("h2",{attrs:{id:"big-key多大算big-如何发现、删除、处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#big-key多大算big-如何发现、删除、处理"}},[a._v("#")]),a._v(" big key多大算big？如何发现、删除、处理？")]),a._v(" "),s("aside",[a._v("\n⚠️ 阿里开发规范：string类型大小控制在10kb内，hash、list、set、zset元素个数不要超过5000个。非字符串的bigkey不要使用del删除，使用hscan、sscan、zscan方式渐进式删除。注意防止bigkey过期时间自动删除问题。\n")]),a._v(" "),s("h3",{attrs:{id:"bigkey危害"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bigkey危害"}},[a._v("#")]),a._v(" bigkey危害")]),a._v(" "),s("ul",[s("li",[a._v("内存不均，集群迁移困难")]),a._v(" "),s("li",[a._v("超时删除，大key删除会调用del命令")]),a._v(" "),s("li",[a._v("造成网络流量阻塞")])]),a._v(" "),s("h3",{attrs:{id:"如何发现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何发现"}},[a._v("#")]),a._v(" 如何发现")]),a._v(" "),s("ol",[s("li",[s("p",[s("code",[a._v("redis-cli --bigkeys")])]),a._v(" "),s("p",[a._v("给出每种数据结构最大的bigkey，同时给出每种数据结构的键值个数和平均大小。")]),a._v(" "),s("p",[a._v("-i second ：每scan100条就会休眠second秒，避免ops剧烈抬升，但是扫描时间会变长。")])]),a._v(" "),s("li",[s("p",[s("code",[a._v("MEMORY USAGE key [SAMPLES count]")])]),a._v(" "),s("p",[a._v("得到key的值和占用的字节数")]),a._v(" "),s("p",[a._v("选项samples ：对于嵌套数据类型，count表示抽样的元素个数，默认为5，要抽样全部元素使用samples 0")])])]),a._v(" "),s("h3",{attrs:{id:"如何删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何删除"}},[a._v("#")]),a._v(" 如何删除")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("string")]),a._v(" "),s("th",[a._v("一般用del，过大用unlink")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("hash")]),a._v(" "),s("td",[a._v("使用hscan每次获取少量filed-value，再使用hdel删除每个field")])]),a._v(" "),s("tr",[s("td",[a._v("set")]),a._v(" "),s("td",[a._v("使用sscan每次获取少量元素，再使用srem删除每个元素")])]),a._v(" "),s("tr",[s("td",[a._v("zset")]),a._v(" "),s("td",[a._v("使用zscan每次获取少量元素，再使用zremrangebyrank删除每个元素")])]),a._v(" "),s("tr",[s("td",[a._v("list")]),a._v(" "),s("td",[a._v("使用ltrim渐进式逐步删除，直到全部删除")])])])]),a._v(" "),s("h2",{attrs:{id:"惰性释放lazyfree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#惰性释放lazyfree"}},[a._v("#")]),a._v(" 惰性释放lazyfree？")]),a._v(" "),s("p",[a._v("当value很大时，采用阻塞删除（del/flashdb/flashall）可能会导致服务器阻塞很长时间，所以要开启lazyfree采用非阻塞删除（unlink/flushdb和flushall的async选项）")]),a._v(" "),s("h3",{attrs:{id:"主动惰性删除操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主动惰性删除操作"}},[a._v("#")]),a._v(" "),s("strong",[a._v("主动惰性删除操作")])]),a._v(" "),s("ul",[s("li",[a._v("UNLINK命令")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("使用UNLINK删除集合键时，会按照集合键的元素去估算释放该KEY的成本，\n如果释放成本超过LAZYFREE_THRESHOLD，则会采用Lazy Free方式进行处理。\n")])])]),s("ul",[s("li",[a._v("FLUSHALL/FLUSHDB")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("通过ASYNC选项来设置FLUSHALL操作或FLUSHDB操作是否采用Lazy Free方式处理。\n")])])]),s("h3",{attrs:{id:"被动使用惰性删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#被动使用惰性删除"}},[a._v("#")]),a._v(" "),s("strong",[a._v("被动使用惰性删除")])]),a._v(" "),s("p",[a._v("被动使用惰性删除主要有下面四类场景,并通过四个参数进行控制：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("## 在内存到达最大内存需要逐出数据时使用## 建议关闭，避免内存未及时释放\nlazyfree-lazy-eviction no\n\n## 在KEY过期时使用## 建议开启\nlazyfree-lazy-expire no\n\n## 隐式删除服务器数据时，如RENAME操作## 建议开启\nlazyfree-lazy-server-del no\n\n## 在对从库进行全量数据同步时## 建议关闭\nslave-lazy-flush no\n")])])]),s("h2",{attrs:{id:"遍历大量数据可以用keys-吗-海量数据查询某一固定前缀的key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历大量数据可以用keys-吗-海量数据查询某一固定前缀的key"}},[a._v("#")]),a._v(" 遍历大量数据可以用keys *吗/海量数据查询某一固定前缀的key")]),a._v(" "),s("p",[a._v("不可以。用keys*查询大量数据可能会导致长时间阻塞（几秒钟）。应该使用scan命令来避免卡顿。")]),a._v(" "),s("p",[a._v("scan命令的match也可以匹配查询key。")]),a._v(" "),s("h3",{attrs:{id:"关于scan命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于scan命令"}},[a._v("#")]),a._v(" 关于scan命令")]),a._v(" "),s("div",{staticClass:"language-jsx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SCAN")]),a._v(" cursor "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MATCH")]),a._v(" patttern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("COUNT")]),a._v(" count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),s("p",[a._v("scan命令是一个基于游标的迭代器，每次调用后会返回两个元素。第一个元素是新的游标，用来作为下一次scan命令的游标参数；第二个元素为检索结果的数组。如果返回的游标为0则说明迭代结束。")]),a._v(" "),s("p",[a._v("可以指定每次返回的数量，但不一定返回指定数量的结果。")]),a._v(" "),s("p",[s("RouterLink",{attrs:{to:"/blogs/Redis/Scan命令 d36fc05ba13040a7af39db5bda889461.html"}},[a._v("Scan命令")])],1),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.lixueduan.com/posts/redis/redis-scan/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.lixueduan.com/posts/redis/redis-scan/"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);