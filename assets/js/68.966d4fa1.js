(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{592:function(e,n,a){"use strict";a.r(n);var t=a(2),i=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"mybatis代理对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mybatis代理对象"}},[e._v("#")]),e._v(" Mybatis代理对象")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class UserService {\n    @Autowired\n    private UserMapper userMapper;\n\n    public void test() {\n        System.out.println(userMapper);\n    }\n}\n")])])]),n("blockquote",[n("p",[e._v("问题：想要拿到mybatis创建的代理对象并且赋值给userMapper属性，需要让Mybatis生成的mapper代理对象变成一个bean。如何做到？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决： 写一个MyFactoryBean类实现FactoryBean类")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class MyFactoryBean implements FactoryBean {\n    @Override\n    public Object getObject() throws Exception {\n        Object instance = Proxy.newProxyInstance(MyFactoryBean.class.getClassLoader(), new Class[]{UserMapper.class}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                return null;\n            }\n        });\n\n        return instance;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return UserMapper.class;\n    }\n}\n")])])]),n("blockquote",[n("p",[e._v("调用applicationContext.getBean(“myFactoryBean”)返回的是getObject()方法返回的代理对象\n调用applicationContext.getBean(“&myFactoryBean”)返回的是MyFactoryBean本身的bean\n因此我们自己实现了创建mapper的代理对象，将其变成一个bean并赋值给service中的属性。")])]),e._v(" "),n("blockquote",[n("p",[e._v("那如何拿到mybatis创建的代理对象？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决： 在MyFactoryBean里，")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private SqlSession sqlSession;\n\n@Autowired\npublic void setSqlSession(SqlSessionFactory sqlSessionFactory) {\n    sqlSessionFactory.getConfiguration().addMapper(UserMapper.class);\n    this.sqlSession = sqlSessionFactory.openSession();\n}\n\n@Override\npublic Object getObject() throws Exception {\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    return mapper;\n}\n")])])]),n("blockquote",[n("p",[e._v("通过SqlSessionFactory拿到sqlSession，再通过sqlSession拿到mb创建的代理对象。\n而SqlSessionFactory需要再config类中自己配置。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Bean\npublic SqlSessionFactory sqlSessionFactory() throws Exception {\n    InputStream is = Resources.getResourceAsStream("mybatis. xml");\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n    return sqlSessionFactory;\n}\n')])])]),n("h2",{attrs:{id:"动态mapper"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态mapper"}},[e._v("#")]),e._v(" 动态mapper")]),e._v(" "),n("blockquote",[n("p",[e._v("问题：如何实现动态的mapper？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决： 在MyFactoryBean添加属性private Class\nmapperClass，通过构造方法对mapperClass赋值")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class MyFactoryBean implements FactoryBean {\n    @Override\n    public Class<?> getObjectType() {\n        return mapperClass;\n    }\n\n    public MyFactoryBean(Class mapperClass) {\n        this.mapperClass = mapperClass;\n    }\n\n    private SqlSession sqlSession;\n    private Class mapperClass;\n\n    @Autowired\n    public void setSqlSession(SqlSessionFactory sqlSessionFactory) {\n        sqlSessionFactory.getConfiguration().addMapper(mapperClass);\n        this.sqlSession = sqlSessionFactory.openSession();\n    }\n\n    @Override\n    public Object getObject() throws Exception {\n        //UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        return sqlSession.getMapper(mapperClass);\n    }\n}\n")])])]),n("blockquote",[n("p",[e._v("问题：但是方法返回的只有一个bean，我们想要所有的bean，如何实现？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决： 使用beanDefinition")])]),e._v(" "),n("p",[e._v("在main方法中：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();\n\napplicationContext.register(AppConfig.class);\n\n//得到beanDefinition\nAbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();\nbeanDefinition.setBeanClass(MyFactoryBean.class);\n//通过该方法对构造器赋值，此处赋值为UserMapper.class，从而实现动态mapper\nbeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);\n//注册beanDefinition ，定义一个叫UserMapper的bean\napplicationContext.registerBeanDefinition("UserMapper",beanDefinition);\napplicationContext.refresh();\n')])])]),n("blockquote",[n("p",[e._v("问题：为什么要手动写register和refresh？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案：\n因为中间插入了自定义的beanDefinition，要将这两步单独拿出来执行")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：为什么beanDefinition.setBeanClass(MyFactoryBean.class)？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案：因为如果传入UserMapper.class，UserMapper是接口不会产生对象\n传入UserMapper.class后，会生成其对象。spring发现是一个FactoryBean，就会调用getObject方法，userMapper属性对应的代理对象作为另外一个bean对象被返回")])]),e._v(" "),n("p",[n("em",[e._v("这几行会生成两个对象，一个MyFactoryBean的对象，一个UserMapper的代理对象\n因为使用了beanDefinition，所以不用在MyFactoryBean类中加@Component注解类")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：把得到beanDefinition的定义都写在main方法里很不美观，如何解决？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决：写一个类MyImportBeanDefinitionRegistrar实现ImportBeanDefinitionRegistrar接口，把定义代码写入重写的registerBeanDefinitions方法。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {\n        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();\n        beanDefinition.setBeanClass(MyFactoryBean.class);\n        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);\n\n        registry.registerBeanDefinition("UserMapper",beanDefinition);\n    }\n}\n')])])]),n("blockquote",[n("p",[e._v("最后在config类中加入注解@Import(MyImportBeanDefinitionRegistrar.class)")])]),e._v(" "),n("h2",{attrs:{id:"mapper扫描"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mapper扫描"}},[e._v("#")]),e._v(" Mapper扫描")]),e._v(" "),n("blockquote",[n("p",[e._v("问题：由于spring的FactoryBean和ImportBeanDefinitionRegistra类都封装在jar包里，我们无法在ImportBeanDefinitionRegistra类中写入自己的mapper，如何解决？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决：创建一个注解@MyMapperScan")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Import(MyImportBeanDefinitionRegistrar.class)\n\npublic @interface MyMapperScan {\n    String value() default "";\n}\n')])])]),n("blockquote",[n("p",[e._v("在config类引用注解@MyMapperScan(“com.xiang.mapper”)\n在MyImportBeanDefinitionRegistra的registerBeanDefinitions方法实现扫描所有mapper")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Override\npublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {\n\n    Map<String, Object> annotationAttributes = importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName());\n    String path = (String) annotationAttributes.get("value");  //根据注解得到mapper类的路径\n\n    //接下来扫描mapper\n    MyMapperScanner myMapperScanner = new MyMapperScanner(registry);\n    myMapperScanner.scan(path);\n\n    //注册bean\n    AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();\n    beanDefinition.setBeanClass(MyFactoryBean.class);\n\n    //给构造方法添加参数（重要！）\n    beanDefinition.getConstructorArgumentValues()\n    .addGenericArgumentValue(UserMapper.class);\n    registry.registerBeanDefinition("UserMapper",beanDefinition);\n}\n')])])]),n("blockquote",[n("p",[e._v("新建一个扫描类MyMapperScanner继承spring创建bean的扫描类ClassPathBeanDefinitionScanner，用于扫描mapper")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：\n但是spring的扫描类不会扫描接口，因为接口无法创建bean。恰恰相反，mybatis的扫描需要扫描mapper接口，如何解决？")])]),e._v(" "),n("blockquote",[n("p",[e._v("在MyMapperScanner中重写isCandidateComponent，设置只关心接口；重写doScan，生成beanDefinition")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class MyMapperScanner extends ClassPathBeanDefinitionScanner {\n    public MyMapperScanner(BeanDefinitionRegistry registry) {\n        super(registry);\n    }\n\n    //设置只关心接口\n    @Override\n    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n        return beanDefinition.getMetadata().isInterface();\n    }\n\n    //生成beanDefinition\n    @Override\n    protected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n        Set<BeanDefinitionHolder> beanDefinitionHolders = super.doScan(basePackages);\n        return beanDefinitionHolders;\n    }\n}\n")])])]),n("blockquote",[n("p",[e._v("但是doScan方法里面的beanDefinitionHolders为空，可以在MyImportBeanDefinitionRegistrar的registerBeanDefinitions方法加入myMapperScanner.addIncludeFilter()解决（以后解释）")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("MyMapperScanner myMapperScanner = new MyMapperScanner(registry);\n\nmyMapperScanner.addIncludeFilter(new TypeFilter() {\n    @Override\n    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\n        return true;\n    }\n});\n\nmyMapperScanner.scan(path);\n")])])]),n("blockquote",[n("p",[e._v("问题：\n这样得到的beanDefinition类型是UserMapper.class，而我们设置的是MyFactoryBean.class")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决：在MyMapperScanner中改写doScan方法，修改错误的beanDefinition类型")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\nprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    Set<BeanDefinitionHolder> beanDefinitionHolders = super.doScan(basePackages);\n\n    for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n        BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();\n        //先设置构造方法参数\n        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());\n        //修改错误的beanDefinition类型\n        beanDefinition.setBeanClassName(MyFactoryBean.class.getName());\n    }\n    return beanDefinitionHolders;\n}\n")])])]),n("p",[e._v("此时可以直接通过在service中注解注入mapper来实现mapper代理对象的获取")])])}),[],!1,null,null,null);n.default=i.exports}}]);