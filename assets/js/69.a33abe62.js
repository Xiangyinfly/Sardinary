(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{594:function(e,n,a){"use strict";a.r(n);var t=a(2),r=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"一些注解类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一些注解类"}},[e._v("#")]),e._v(" 一些注解类")]),e._v(" "),n("p",[e._v("@ComponentScan")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ComponentScan {\n    String value() default "";\n}\n')])])]),n("p",[e._v("@Component")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Component {\n    String value() default "";\n}\n')])])]),n("p",[e._v("@Scope")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Scope {\n    String value() default "";\n}\n')])])]),n("p",[e._v("@Autowired")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Autowired {\n}\n")])])]),n("h2",{attrs:{id:"建立beandefinition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建立beandefinition"}},[e._v("#")]),e._v(" 建立BeanDefinition")]),e._v(" "),n("p",[n("em",[e._v("BeanDefinition与Bean的关系, 就好比类与对象的关系.\n类在spring的数据结构就是BeanDefinition.")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class BeanDefinition {\n    private Class type;\n    private String scope;\n\n    public Class getType() {\n        return type;\n    }\n\n    public void setType(Class type) {\n        this.type = type;\n    }\n\n    public String getScope() {\n        return scope;\n    }\n\n    public void setScope(String scope) {\n        this.scope = scope;\n    }\n}\n")])])]),n("h2",{attrs:{id:"myapplicationcontext类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#myapplicationcontext类"}},[e._v("#")]),e._v(" MyApplicationContext类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyApplicationContext {\n    private Class configClass;\n    private ConcurrentHashMap<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<String,Object> singletonObjects = new ConcurrentHashMap<>();\n\n    public MyApplicationContext(Class configClass) {\n        this.configClass = configClass;\n\n        //扫描类的注解\n        if (configClass.isAnnotationPresent(ComponentScan.class)) {\n            ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);\n            String path = componentScanAnnotation.value();\n            path = path.replace(".","/");\n\n            ClassLoader classLoader = MyApplicationContext.class.getClassLoader();\n            URL resource = classLoader.getResource(path);\n\n            File file = new File(resource.getFile());\n            System.out.println(file);\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (File f : files) {\n                    String fileName = f.getAbsolutePath();\n                    if (fileName.endsWith(".class")) {\n                        String className = (path + "/" + f.getName().substring(0,f.getName().indexOf(".class"))).replace("/",".");\n\n                        try {\n                            Class<?> clazz = classLoader.loadClass(className);\n\n                            if (clazz.isAnnotationPresent(Component.class)) {\n                                String beanName = clazz.getAnnotation(Component.class).value();\n                                if ("".equals(beanName)) {\n                                    beanName = Introspector.decapitalize(clazz.getSimpleName());\n                                }\n\n                                BeanDefinition beanDefinition = new BeanDefinition();\n                                beanDefinition.setType(clazz);\n                                if (clazz.isAnnotationPresent(Scope.class)) {\n                                    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);\n                                    beanDefinition.setScope(scopeAnnotation.value());\n                                } else {\n                                    beanDefinition.setScope("singleton");\n                                }\n\n                                beanDefinitionMap.put(beanName,beanDefinition);\n                            }\n                        } catch (ClassNotFoundException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                }\n            }\n        }\n\n        //create所有的单例bean\n        beanDefinitionMap.keySet().forEach(beanName -> {\n            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n            if (beanDefinition.getScope().equals("singleton")) {\n                Object bean = createBean(beanName,beanDefinition);\n                singletonObjects.put(beanName,bean);\n            }\n        });\n    }\n    //创建bean\n    public Object createBean(String beanName,BeanDefinition beanDefinition) {\n        Class clazz = beanDefinition.getType();\n        try {\n            Object instance = clazz.getConstructor().newInstance();\n\n            //简易DI\n            for (Field f : clazz.getDeclaredFields()) {\n                if (f.isAnnotationPresent(Autowired.class)) {\n                    f.setAccessible(true);\n                    //把带autowired注解的字段的实例设置为getBean(f.getName())\n                    f.set(instance,getBean(f.getName()));\n                }\n            }\n\n            return instance;\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(e);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    //getBean方法实现\n    public Object getBean(String beanName) {\n        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n        if (beanDefinition == null) {\n            throw new NullPointerException();\n        }\n\n        String scope = beanDefinition.getScope();\n\n        //单例\n        if (scope.equals("singleton")) {\n            Object bean = singletonObjects.get(beanName);\n\n            /*\n            此处空处理的原因：比如，在创建UserService的bean的时候，createBean方法中会进行依赖注入OrderService，\n            而此时会调用getBean方法（f.set(instance,getBean(f.getName()));），但这时可能单例库里还没有OrderService，\n            所以要进行空处理并且将其加入单例库\n             */\n            //未解决循环依赖问题\n            if (bean == null) {\n                bean = createBean(beanName,beanDefinition);\n            }\n            return bean;\n        }\n\n        return createBean(beanName,beanDefinition);\n    }\n}\n')])])]),n("h2",{attrs:{id:"aware回调"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aware回调"}},[e._v("#")]),e._v(" Aware回调")]),e._v(" "),n("p",[e._v("在spring文件夹中创建接口BeanNameAware")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface BeanNameAware {\n    void setBeanName(String beanName);\n}\n")])])]),n("p",[e._v("MyApplicationContext中的createBean方法写入")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public Object createBean(String beanName,BeanDefinition beanDefinition) {\n    ...\n        //beanName的aware回调\n        if (instance instanceof BeanNameAware) {\n            ((BeanNameAware)instance).setBeanName(beanName);\n        }\n    ...\n}\n")])])]),n("p",[e._v("service类要实现BeanNameAware，才能进行aware回调")]),e._v(" "),n("h2",{attrs:{id:"spring的初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring的初始化"}},[e._v("#")]),e._v(" Spring的初始化")]),e._v(" "),n("p",[e._v("创建接口InitializeBean，需要service类实现该接口")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface InitializeBean {\n    void afterPropertiesSet();\n}\n")])])]),n("p",[e._v("MyApplicationContext中的createBean方法写入")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\npublic Object createBean(String beanName,BeanDefinition beanDefinition) {\n    ...\n        //类的初始化\n        if (instance instanceof InitializeBean) {\n            ((InitializeBean)instance).afterPropertiesSet();\n        }\n    ...\n}\n\n")])])]),n("h2",{attrs:{id:"beanpostprocessor机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beanpostprocessor机制"}},[e._v("#")]),e._v(" BeanPostProcessor机制")]),e._v(" "),n("p",[e._v("创建接口BeanPostProcessor")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface BeanPostProcessor {\n    void postProcessorBeforeInitialization(String beanName,Object bean);\n    void postProcessorAfterInitialization(String beanName,Object bean);\n}\n")])])]),n("p",[e._v("创建自定义的MyBeanPostProcessor类实现BeanPostProcessor接口及其方法，在其中对service类实现操作，并将MyBeanPostProcessor加入Spring容器（@Component）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public void postProcessorBeforeInitialization(String beanName, Object bean) {\n    //根据beanName名字判断/根据bean类型判断\n    //操作\n    }\n\n    @Override\n    public void postProcessorAfterInitialization(String beanName, Object bean) {\n\n    }\n}\n")])])]),n("p",[e._v("创建BeanPostProcessor的list集合以放入实现该接口的实例。\n扫描类注解时加入（在MyApplicationContext的构造方法）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("...\nprivate ArrayList<BeanPostProcessor> beanPostProcessors = new ArrayList<>();\n...\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if (clazz.isAnnotationPresent(Component.class)) {\n    if (BeanPostProcessor.class.isAssignableFrom(clazz)) {  //该类实现接口\n        BeanPostProcessor instance = (BeanPostProcessor) clazz.newInstance();\n        beanPostProcessors.add(instance);\n\n    }\n\n    String beanName = clazz.getAnnotation(Component.class).value();\n    if ("".equals(beanName)) {\n        beanName = Introspector.decapitalize(clazz.getSimpleName());\n    }\n    ...\n')])])]),n("p",[e._v("在createBean方法类初始化前后实现BeanPostProcessor实现类的自定义方法中的操作")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("...\n//beanName的aware回调\nif (instance instanceof BeanNameAware) {\n    ((BeanNameAware)instance).setBeanName(beanName);\n}\n\n//实现BeanPostProcessor方法\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessors) {\n    beanPostProcessor.postProcessorBeforeInitialization(beanName,instance);\n}\n\n//类的初始化\nif (instance instanceof InitializeBean) {\n    ((InitializeBean)instance).afterPropertiesSet();\n}\n\n//实现BeanPostProcessor方法\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessors) {\n    beanPostProcessor.postProcessorAfterInitialization(beanName,instance);\n}\n...\n")])])]),n("h2",{attrs:{id:"aop机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aop机制"}},[e._v("#")]),e._v(" AOP机制")]),e._v(" "),n("p",[e._v("现在createBean方法return的是一个普通对象，而AOP要求返回的对象是一个代理对象")]),e._v(" "),n("p",[e._v("使用jdk代理（service类需要接口）\n目标：createBean方法经过BeanPostProcessor实现类的方法后返回代理对象")]),e._v(" "),n("p",[e._v("修改接口BeanPostProcessor返回值")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface BeanPostProcessor {\n    Object postProcessorBeforeInitialization(String beanName,Object bean);\n    Object postProcessorAfterInitialization(String beanName,Object bean);\n}\n")])])]),n("p",[e._v("修改MyBeanPostProcessor类 代理逻辑中实现切面方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Component\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessorBeforeInitialization(String beanName, Object bean) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessorAfterInitialization(String beanName, Object bean) {\n        if (beanName.equals("userService")) {\n            Object proxyInstance = Proxy.newProxyInstance(MyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), new InvocationHandler() {\n                @Override\n                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                    //切面逻辑\n                    return method.invoke(bean,args);\n                }\n            });\n\n            return proxyInstance;  //return一个代理对象\n        }\n        return bean;\n    }\n}\n')])])]),n("p",[e._v("修改createBean方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//beanName的aware回调\nif (instance instanceof BeanNameAware) {\n    ((BeanNameAware)instance).setBeanName(beanName);\n}\n\n//实现BeanPostProcessor方法\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessors) {\n    instance = beanPostProcessor.postProcessorBeforeInitialization(beanName,instance);\n}\n\n//类的初始化\nif (instance instanceof InitializeBean) {\n    ((InitializeBean)instance).afterPropertiesSet();\n}\n\n//实现BeanPostProcessor方法\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessors) {\n    instance = beanPostProcessor.postProcessorAfterInitialization(beanName,instance);\n}\n\nreturn instance;\n")])])]),n("p",[e._v("如果经过BeanPostProcessor方法，此时return的instance就是我们自定义的代理对象")]),e._v(" "),n("h2",{attrs:{id:"bean的生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bean的生命周期"}},[e._v("#")]),e._v(" Bean的生命周期")]),e._v(" "),n("h3",{attrs:{id:"bean创建的生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bean创建的生命周期"}},[e._v("#")]),e._v(" bean创建的生命周期")]),e._v(" "),n("blockquote",[n("p",[e._v("service.class -> 推断构造方法 -> 对象 -> DI ->\n初始化前（@PostConstruct） -> 初始化\n（afterPropertiesSet方法） -> 初始化后 （AOP） -> （代理对象）\n-> 放入单例池 -> bean对象")])]),e._v(" "),n("h3",{attrs:{id:"初始化前和初始化时"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化前和初始化时"}},[e._v("#")]),e._v(" 初始化前和初始化时")]),e._v(" "),n("p",[e._v("假设service类中有一个属性private User\nadmin，如何给在bean创建的时候给这个属性赋值？\n如果利用Autowired，spring并不知道该给admin赋值为什么（比如查询数据库得到赋值），所以要自定义方法来给admin赋值。")]),e._v(" "),n("blockquote",[n("p",[e._v("实现1:\n此时可以写一个方法f，在f中实现admin的赋值逻辑，并在初始化前进行f的调用。\n如何进行初始化前调用？在方法上使用@PostConstruct注解")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("逻辑如下：\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for(Method method: Service. getClass). getDeclaredMethods()) {\n        if (method.isAnnotationPresent(PostConstruct.class)) {\n            method.invoke(userService1,null);\n    }\n")])])]),n("blockquote",[n("p",[e._v("实现2:\nservice类实现InitializingBean接口，重写其中的afterPropertiesSet方法，在方法中实现逻辑赋值\n该方法会在spring初始化的时候被调用")])]),e._v(" "),n("blockquote",[n("p",[e._v("该方法的实现逻辑：\n进入AbstractAutowiredCapableBeanFactory类的doCreateBean方法，\n用构造方法得到对象实例， 解决循环依赖问题， populatedBean方法属性填充，\ninitializeBean方法 { aware回调， 初始化前，\n初始化：判断有没有实现InitializingBean，执行afterPropertiesSet方法，\n初始化后 }， ……")])]),e._v(" "),n("h3",{attrs:{id:"推断构造方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#推断构造方法"}},[e._v("#")]),e._v(" 推断构造方法")]),e._v(" "),n("p",[e._v("推断构造方法的底层原理？")]),e._v(" "),n("blockquote",[n("p",[e._v("Q1：private OrderService\norderService并未加@Autowired注解。如果有1，输出什么？如果有1、2，输出什么？如果有2、3，输出什么？")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class UserService {\n    private OrderService orderService;\n    1️⃣public UserService() {\n        System.out.println(0);\n    ｝\n    2️⃣public UserService(OrderService orderService) {\n        this.orderService = orderService;\n        System.out.println(1);\n    }\n    3️⃣public UserService(OrderService orderService, OrderService orderService1) {\n        this.orderService = orderService;\n        System.out.println(2);\n    }\n    ...\n")])])]),n("blockquote",[n("p",[e._v("结果： 1.输出0，并且属性orderService为null。\n2.输出1，并且属性orderService不为空。 3.报错")])]),e._v(" "),n("blockquote",[n("p",[e._v("原因分析： 如过仅存在一个构造方法，则spring会调用该构造方法；\n如果存在多个构造方法，则spring会在这些构造方法中寻找无参构造方法。如果找到就会调用，找不到就会报错。")])]),e._v(" "),n("blockquote",[n("p",[e._v("Q2：如何让spring调用指定的构造方法？\n在想被调用的构造方法加上@Autowired注解")])]),e._v(" "),n("blockquote",[n("p",[e._v("Q3：前面结果2属性orderService不为null，spring如何为属性赋值？\n属性如果不是bean，则会报错；\n属性如果是单例bean，就会去单例池里寻找，如果有就会赋值，没有会创建bean；\n属性如果不是单例bean，就会直接创建bean")])]),e._v(" "),n("blockquote",[n("p",[e._v("Q4：在map<beanName,Bean对象>单例池中寻找bean的时候，如果根据beanName查找不可行，因为public\nUserService(OrderService\norderService)中形参名字可以随便取。所以根据类型来取得。但是根据类型获取会出现一个value对应多个key的情况，或者多个value都是同一类型。如何解决？")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class OrderService {}\n\n@Bean\npublic OrderService orderService1(){return new OrderService();}\n@Bean\npublic OrderService orderService2(){return new OrderService();}\n\n//这三个orderService不是一个对象，但是类型相同（即多个value都是同一类型）\n")])])]),n("blockquote",[n("p",[e._v("解决方法：先根据type查找。如果type查到有多个，就根据name筛选；如果只查到一个，就直接赋值。")])]),e._v(" "),n("blockquote",[n("p",[e._v("因此，推断构造方法有两步： 1.选择构造方法\n2.实现构造方法入参属性赋值")])]),e._v(" "),n("h3",{attrs:{id:"依赖注入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入"}},[e._v("#")]),e._v(" 依赖注入")]),e._v(" "),n("p",[e._v("依赖注入的原理？")]),e._v(" "),n("blockquote",[n("p",[e._v("1.查找属性 2.与构造方法入参相同的方法进行属性赋值")])]),e._v(" "),n("h3",{attrs:{id:"代理对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代理对象"}},[e._v("#")]),e._v(" 代理对象")]),e._v(" "),n("p",[e._v("Q1：放入单例池的是原对象还是代理对象？")]),e._v(" "),n("blockquote",[n("p",[e._v("如果需要实现AOP，则放入的是代理对象；\n如果不需要，则放入的是原对象")])]),e._v(" "),n("p",[e._v("Q2：代理对象被标记@Autowired的属性的值是否为空？")]),e._v(" "),n("blockquote",[n("p",[e._v("属性值为空，因为代理对象产生后并未进行DI就加入了单例池。")])]),e._v(" "),n("p",[e._v("Q3：如果为空，那为什么打印输出该属性的时候并不为空？ >\n代理类创建时有一个target属性，并将代理类的普通类赋值给该target属性。调用test方法时，执行的是代理类的test方法。代理类的test方法先进行AOP，然后调用target.test()，即调用普通类的test方法。target是普通类进行了DI，因此避免了属性为空的问题。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class UserServiceProxy extends UserService {\n    UserService target;\n    public void test(){\n        //切面逻辑@Before\n        //target.test();//普通对象.test()\n    }\n}\n")])])]),n("p",[e._v("Q4：Q3为什么通过建立target属性来解决而不是直接调用super.test()？ >\n？？我也不清楚")]),e._v(" "),n("p",[e._v("Q5：代理类可以不继承普通类吗？（cglib代理） >\n不可以。不继承就不能将代理类强制转换为普通类了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('UserService userService = (UserService) applicationContext.getBean("userService")\n')])])]),n("h2",{attrs:{id:"事务管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务管理"}},[e._v("#")]),e._v(" 事务管理")]),e._v(" "),n("p",[e._v("事务切面逻辑：")]),e._v(" "),n("blockquote",[n("p",[e._v("添加@Transaction注解开启事务 -> 事务管理器\n新建数据库连接connection -> connection.autocommit = false ->\ntarget.test() -> connection.commit()/rollback()")])]),e._v(" "),n("p",[e._v("Q1：为什么spring会让事务管理器建立连接，而不直接让jdbcTemplate建立连接？")]),e._v(" "),n("blockquote",[n("p",[e._v("因为jdbcTemplate建立的连接默认autocommit =\ntrue，会直接提交，起不到事务管理的作用")])]),e._v(" "),n("p",[e._v("Q2：在service类中添加如下方法，调用test方法，a方法的@Transactional注解会不会起作用？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Transactional\npublic void test() {\n    jdbcTemplate.execute("...");\n    a();\n}\n\n@Transactional(propagation = Propagation.NEVER)\npublic void a {\n    jdbcTemplate.execute("...");\n}\n...\n\n')])])]),n("blockquote",[n("p",[e._v("不会。 -> 调用service.test() -> 进入代理类的test方法 ->\n代理了执行target.test() -> 由于target为普通service类，@Transactional注解不起作用\n-> 不会抛出异常（正常情况下@Transactional(propagation =\nPropagation.NEVER)会导致抛出异常）")]),e._v(" "),n("p",[e._v("为什么test方法的@Transactional注解有用？\n因为调用service.test()时执行方法的是代理类，会去处理@Transactional注解。而执行a方法的时候只是普通类。")])]),e._v(" "),n("p",[e._v("Q3：如何解决Q2的问题？")]),e._v(" "),n("blockquote",[n("p",[e._v("1.拆分类：拆分出另外一个类s1，在s1中写a方法，再将s类注入原service(s)类，在test方法中调用s.a()即可\n2.自己注入自己\n3.其他方法拿到当前类代理对象，例如AopContext.currentProxy()")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Autowired\nprivate Service s1;\n\n@Transactional\npublic void test() {\n    jdbcTemplate.execute("...");\n    s1.a();\n}\n\n=================================\n\n@Autowired\nprivate Service s;\n\n@Transactional\npublic void test() {\n    jdbcTemplate.execute("...");\n    s.a();\n}\n')])])]),n("p",[e._v("Q4：@Configuration注解对事务管理的影响（config类不加@Configuration注解错误问题）")]),e._v(" "),n("blockquote",[n("p",[e._v("我们知道， 1️⃣\nspring的事务管理器创建connection放在LocalThread<Map<Datasource,connection>>中。\n“为什么泛形里面放的是map而不直接是connection?\n因为现实工程中可能会使用多种datasource。” 2️⃣\n不加@Configuration注解时，jdbcTemplate和事务管理器创建的datasource对象不是同一个对象，只有事务管理器创建出来的对象才有事务处理的功能，jdbcTemplate的autocommit\n= true")]),e._v(" "),n("p",[e._v("因此，加上@Configuration注解会使jdbcTemplate调用的是事务管理器创建的datasource，而不会自己再创建一个新的datasource，避免事务管理的失效。")])]),e._v(" "),n("p",[e._v("Q5：@Configuration注解解决Q4的原理？")]),e._v(" "),n("blockquote",[n("p",[e._v("@Configuration，AOP，@Lazy都是使用的动态代理机制\nAppConfig加上@Configuration注解之后会生成一个动态代理类")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public classAppConfig {//config类\n    @Bean\n    public IdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource());\n    }\n    @Bean\n    public PlatformTransactionManager transactionManager() {\n        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();\n        transactionManager.setDataSource(dataSource());\n        return transactionManager;\n    }\n    @Bean\n    public void datasource() {\n        ...\n    }\n\n    ...\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class UserServiceProxy extends AppConfig｛//config代理类\n    UserService target;\n    public void jdbcTemplate(){\n        //代理逻辑\n        super.jdbcTemplate();\n    }\n    public void datasource(){\n        //代理逻辑\n    }\n｝\n")])])]),n("blockquote",[n("p",[e._v("config类中jdbcTemplate()和transactionManager()方法中的datasource()方法都是代理类调用的")])]),e._v(" "),n("blockquote",[n("p",[e._v("代理类来调用jdbcTemplate()和datasource()方法。\n代理类在调用这两个方法时，会首先执行代理逻辑。即：在执行jdbcTemplate()方法时，先检测spring容器里面有没有datasource，如果有就直接返回spring容器中的datasource；如果没有就调用datasource()方法去创建一个datasource并放入spring容器。\n通过这种方式来保证jdbcTemplate()和datasource()得到的是同一个datasource")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//在config类中\n\n@Bean\npublic JdbcTemplate jdbcTemplate() {\n    return new JdbcTemplate (dataSource)());\n}\n@Bean\npublic PlatformTransactionManager transactionManager() {\n    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();\n    transactionManager.setDataSource(dataSource1());\n    return transactionManager;\n}\n")])])]),n("blockquote",[n("p",[e._v("上述代码的情况：如果jdbcTemplate()和transactionManager()方法中的datasource不是同一个，即使加@Configuration注解也会出现Q4错误")])]),e._v(" "),n("h2",{attrs:{id:"循环依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#循环依赖"}},[e._v("#")]),e._v(" 循环依赖")]),e._v(" "),n("blockquote",[n("p",[e._v("三级缓存(三个map) singletonobjects(即单例池) ->\n保存拥有完整生命周期的bean earlySingletonobjects ->\nbean被循环依赖，提前产生一个代理对象，保存到二级缓存，保证单例\nsingletonFactories ->\n打破循环，先存到三级缓存，出现循环依赖的情况下才能拿到被依赖的对象")])]),e._v(" "),n("h3",{attrs:{id:"引入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引入"}},[e._v("#")]),e._v(" 引入")]),e._v(" "),n("blockquote",[n("p",[e._v("背景：AService类注入了BService类属性，BService类注入了AService类属性")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决方法：利用一个map解决循环依赖问题")])]),e._v(" "),n("p",[e._v("AService的Bean的生命周期： 1.\n\ufeff\ufeff实例化—>AService普通对象—>map.put(“AService”,AService普通对象） 2.\n\ufeff\ufeff\ufeff填充bService—>单例池Map—>创建BService BService的Bean的生命周期：")]),e._v(" "),n("ol",[n("li",[e._v("实例化—>普通对象 2.\n\ufeff\ufeff填充aService—>单例池Map—>map—>AService普通对象 3. \ufeff\ufeff填充其他属性")]),e._v(" "),n("li",[e._v("做一些其他的事情（AOP）—> AService的代理对象 5. \ufeff\ufeff\ufeff添加到单例池 3.\n\ufeff\ufeff填充其他属性 4. \ufeff\ufeff\ufeff做一些其他的事情 5. \ufeff\ufeff添加到单例池")])]),e._v(" "),n("blockquote",[n("p",[e._v("出现问题：注入bService的AService属性是AService的普通对象，而加入单例池是AService的代理对象")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决方法：未出现循环依赖的bean不提前进行AOP，只有出现循环依赖的bean提前进行AOP。加入\ufeffcreatingSet存放正在进行初始化的bean，在第2.2通过检查creatingSet判断循环依赖，决定是否提前进行AOP。")])]),e._v(" "),n("ol",[n("li",[e._v("creatingSet<AService›")]),e._v(" "),n("li",[e._v("实例化–>AService普通对象")]),e._v(" "),n("li",[e._v("填充bService—>单例池Map—>创建BService\nBService的Bean的生命周期： 2.1 实例化–>普通对象 2.2\n填充aService—>单例池Map—>creatingSet—>AService出现了循环依赖—>"),n("em",[e._v("AOP—>\naService代理对象—>添加到单例池")]),e._v(" 2.3 填充其他属性 2.4\n做一些其他的事情（AOP） 2.5 添加到单例池")]),e._v(" "),n("li",[e._v("填充其他属性 *5.\ufeff做一些其他的事情（AOP）—>AService代理对象")]),e._v(" "),n("li",[e._v("添加到单例池*")]),e._v(" "),n("li",[e._v("creatingSet.remove<‘AService’>")])]),e._v(" "),n("blockquote",[n("p",[e._v("出现问题：是否应该将5、6提前到2.2斜体部分？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案：不应该在2.2斜体部分加入单例池。 因为存在一些潜在的问题，例如：")])]),e._v(" "),n("ol",[n("li")]),e._v(" "),n("p",[e._v("此时aService普通对象还未初始化完成，代理对象创建过程中可能拿不到普通对象\n2.\n此时aService普通对象还未初始化完成，因此aService代理对象中的target属性为空或不完整。此时如果有另外一个线程使用单例池中的aService代理对象，就会出现问题。")]),e._v(" "),n("blockquote"),e._v(" "),n("h3",{attrs:{id:"二级缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二级缓存"}},[e._v("#")]),e._v(" 二级缓存")]),e._v(" "),n("blockquote",[n("p",[e._v("出现问题：\n背景：如果aService依赖bService和cService，而bService和cService都依赖aService，那bService和cService在初始化的时候都需要创建aService的代理对象，与单例模式产生矛盾。")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决方法：利用第二级缓存earlySingletonobjects，在b需要a的时候创建a的代理对象并将其加入earlySingletonobjects，c在需要a的时候直接从二级缓存里面拿。")])]),e._v(" "),n("p",[n("em",[e._v("二级缓存的作用：存储出现循环依赖问题时还未完成完整生命周期的早期的bean对象，保持单例性")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：什么时候将aService代理对象加入单例池？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案：在aService填充完所有属性并进行完其他的事情（如AOP）之后，earlySingletonobjects.get(AService)得到a的代理对象，加入单例池")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：第四步“填充其他属性”是aService普通对象还是代理对象？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案：普通对象。代理对象存在的意义仅仅是执行切面逻辑。")])]),e._v(" "),n("h3",{attrs:{id:"三级缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三级缓存"}},[e._v("#")]),e._v(" 三级缓存")]),e._v(" "),n("p",[n("em",[e._v("三级缓存的作用是打破循环。")])]),e._v(" "),n("p",[e._v("singletonFactories里存放的是(beanName，lambda表达式)：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("singletonFactories.put('AService',()-> getEarlyBeanReference(beanName,mbd,AService普通对象))\n")])])]),n("p",[e._v("源码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//判断是否是单例，是否支持循环依赖（默认true），是否正在被创建\nboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));\n\n//如果都是\nif(earlySingletonExposure) {\n    if(logger.isTraceEnabled()) {\n        Logger.trace("Eagerly caching bean \'" + beanName + "\'to allow for resolving potential circular references");\n    }\n    //加入三级缓存\n    addSingletonFactory(beanName,() -> getEarlyBeanReference(beanName, mbd,\nbean));\n}\n')])])]),n("p",[e._v("如果在一二级缓存里面都没找到，就去第三级缓存找，执行()->\ngetEarlyBeanReference(beanName,mbd,AService普通对象)。\n如果该bean需要进行AOP，那执行的结果是进行AOP，创建代理对象。\n如果不需要，那执行的结果是返回普通对象。\n最后将代理/普通对象放入二级缓存。")]),e._v(" "),n("p",[e._v("a填充b的属性时，会调用getSingleton方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonobject = this. singletonobjects.get (beanName);\n    if(singletonObject == null &d isSingletonCurrentlyInCreation(beanName)) {//当前索要的对象为空且正在创建中，即出现了循环依赖\n        singletonObject = this. earlySingletonobjects. get (beanName);\n        if (singletonobject == null && allowEarlyReference) {\n            synchronized (this. singletonObjects) {\n            // Consistent creation of early reference within full singleton lock\n                singletonobject = this. singletonobjects.get (beanName);\n                if (singletonobject == null) {\n                    singletonobject = this. earlySingletonobjects.get (beanName);\n                        if (singletonObject == null) {//二级缓存没有\n                            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                                if (singletonFactory != null) {//去三级缓存找\n                                    singletonobject = singletonFactory.getobject;\n                                    this. earlySingletonobjects. put (beanName, singLetonobject);//加入二级缓存中\n                                    this. singletonFactories. remove (beanName);//从三级缓存中移除，即移除lambda表达式\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n")])])]),n("blockquote",[n("p",[e._v("为什么要从三级缓存中移除？")])]),e._v(" "),n("blockquote",[n("p",[e._v("因为对象是单例的，lambda表达式（()->\ngetEarlyBeanReference(beanName,mbd,AService普通对象)）只需要执行一次，保证单例。\n同理，当需要去三级缓存中存的时候，二级缓存中也会执行移除 例如：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert. notNull(singletonFactory, "Singleton factory must not be null");\n    synchronized (this.singletonObjects) {\n        if (!this. singletonobjects. containsKey(beanName)) {\n            this. singletonFactories put(beanName, singletonFactory);\n            this.earlySingleton0bjects.remove(beanName);\n            this.registeredSingletons.add (beanName);\n        }\n    }\n}\n')])])]),n("blockquote",[n("p",[e._v("5、6步之间还会调用getSingleton方法，从二级缓存中拿到代理对象")])]),e._v(" "),n("blockquote",[n("p",[e._v("总结：\n对象创建时，先存在三级缓存中，在出现循环依赖的时候去三级缓存取，然后执行取到的lambda表达式并执行，进行AOP得到代理对象，然后将代理对象存进二级缓存，然后执行接下来的创建步骤，创建完成后放入一级缓存。")])]),e._v(" "),n("h3",{attrs:{id:"map-earlyproxyreferences"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map-earlyproxyreferences"}},[e._v("#")]),e._v(" Map:earlyProxyReferences")]),e._v(" "),n("blockquote",[n("p",[e._v("如果在2.2提前进行AOP，那原本该进行AOP的时候（第5步）如何进行？")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\npublic Object postProcessAfterInitialization (Nullable Object bean, String beanName) {\n    if (bean != null) {\n        Object cacheKey = getCacheKey (bean. getClass), beanName);\n        if (this.earlyProxyReferences.remove(cacheKey) != bean) {\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n｝\n@Override\npublic Object getEarlyBeanReference(Object bean, String beanName) {\n    Object cacheKey = getCacheKey(bean. getClass), beanName);\n    this.earlyProxyReferences.put(cacheKey, bean);\n    return wrapIfNecessary(bean, beanName, cachekey);\n}\n")])])]),n("blockquote",[n("p",[e._v("通过一个map “earlyProxyReferences”来区分bean是否进行过AOP。\ngetEarlyBeanReference方法是lambda表达式调用的方法。如果提前进行AOP，该方法被调用，对该bean产生一个cacheKey放入earlyProxyReferences中，并且调用wrapIfNecessary方法。\npostProcessAfterInitialization是正常AOP调用的方法。if的意义在于判断earlyProxyReferences中是否有该bean的cacheKey。如果有，就直接返回普通对象（此处不必着急返回代理对象，因为5、6步之间还会调用getSingleton方法，从二级缓存中拿到代理对象）；如果没有，即this.earlyProxyReferences.\nremove(cacheKey) == null，就调用wrapIfNecessary方法。")])]),e._v(" "),n("h3",{attrs:{id:"lazy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lazy"}},[e._v("#")]),e._v(" @Lazy")]),e._v(" "),n("blockquote",[n("p",[e._v("问题：如果在a构造方法里（a初始化的时候）加入this.bService =\nbService，则根本创建不出来a的普通对象，因此spring解决不了循环依赖问题。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Component\npublic class AService {\n    private BService bService;\n\n    @Lazy\n    public AService(BService bService) {\n        this.bService = bService;\n    }\n    public void test() {\n        bService.toString();\n    }\n    ...\n")])])]),n("blockquote",[n("p",[e._v("解决方法：加上@Lazy注解。加注解后，在创建a的bean的时候，会创建一个b的代理对象注入a，不会出现循环依赖问题。等到真正调用关于b的方法（例如test方法）的时候，b才会真正被创建出来。\n*也可以解决@Async报错问题。")])])])}),[],!1,null,null,null);n.default=r.exports}}]);