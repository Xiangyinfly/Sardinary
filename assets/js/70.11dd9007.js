(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{593:function(e,n,a){"use strict";a.r(n);var t=a(2),s=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("aside",[e._v("\n💡 ***扫描的结果是beanDefinition***\n")]),e._v(" "),n("h2",{attrs:{id:"componentscan的扫描"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#componentscan的扫描"}},[e._v("#")]),e._v(" @ComponentScan的扫描")]),e._v(" "),n("p",[e._v("解析ComponentScanAnnotationParser类：")]),e._v(" "),n("h3",{attrs:{id:"_1️⃣-new一个scanner"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-new一个scanner"}},[e._v("#")]),e._v(" 1️⃣：new一个scanner")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner (this.registry,componentScan.getBoolean("useDefaultFilters"), this. environment, this. resourceLoader);\n')])])]),n("p",[e._v("this.registry：spring容器，用来放入产生的beanDefinition\ncomponentScan.getBoolean(“useDefaultFilters”)：默认为true，即使用默认的过滤器")]),e._v(" "),n("h3",{attrs:{id:"_2️⃣-扫描器scanner去设置一些属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-扫描器scanner去设置一些属性"}},[e._v("#")]),e._v(" 2️⃣：扫描器scanner去设置一些属性")]),e._v(" "),n("h3",{attrs:{id:"_1-自定义bean名字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-自定义bean名字"}},[e._v("#")]),e._v(" 1.自定义bean名字")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    //自定义bean名字\n    Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");\n    boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);\n    //判断是否为默认值\n    scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :\n                BeanUtils.instantiateClass(generatorClass));\n')])])]),n("p",[e._v("默认的为AnnotationBeanNameGenerator，生成方法如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\npublic String generateBeanName (BeanDefinition definition,BeanDefinitionRegistry\nregistry) {\n    if(definition instanceof AnnotatedBeanDefinition) {\n    //获取注解所指定的beanName\n    //默认为类@Component注解里value属性的值\n        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n        if (StringUtils. hasText (beanName)) {\n        // Explicit bean name found.\n        return beanName;\n    }\n    // Fallback: generate a unique default bean name.\n    //生成默认名\n    return buildDefaultBeanName (definition, registry);\n}\n")])])]),n("p",[e._v("生成默认名的方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('protected String buildDefaultBeanName(BeanDefinition definition) {\n    String beanClassName = definition. getBeanClassName;\n    Assert. state ( beanClassName != null,"No bean class name set");\n    String shortClassName = ClassUtils. getShortName (beanClassName) ;\n    return Introspector. decapitalize(shortClassName);\n｝\n')])])]),n("p",[e._v("我们可以设置一个MyBeanNameGenerator类，实现BeanNameGenerator接口来自定义bean的名字")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyBeanNameGenerator implements BeanNameGenerator {\n    @Override\n    public String generateBeanName(BeanDefinitiondefinition,BeanDefinitionRegistry\nregistry) {\n        return "My"+definition.getBeanClassName();\n    }\n}\n')])])]),n("p",[e._v("然后在config类的@Component注解添加属性nameGenerator =\nMyBeanNameGenerator.class)以起作用")]),e._v(" "),n("h3",{attrs:{id:"_2-设置默认代理模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-设置默认代理模式"}},[e._v("#")]),e._v(" 2.设置默认代理模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");\n        if (scopedProxyMode != ScopedProxyMode.DEFAULT) {\n            scanner.setScopedProxyMode(scopedProxyMode);\n        }\n        else {\n            Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");\n            scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));\n        }\n')])])]),n("p",[e._v("关于scopedProxy属性： 前置知识： 假设s1类加上@Scope\n(WebApplicationContext.\nSCOPE_REQUEST)注解，即只有创建请求的时候才会生成bean。而s2类中有@Autowired的s1类（创建的时候强制要求注入s1），但是在s2创建的时候（即容器初始化的时候），s1并未被创建。spring解决该问题的方法是先生成s1的一个代理对象注入s2，而改代理对象的生成模式由@Scope注解中的proxyMode属性决定（cglib、jdk等）。\n在@ComponentScan注解的scopeProxy属性中也可以批量配置类的代理对象生成模式。\n如果类的@Scope注解中未配置代理模式，就使用@ComponentScan注解所配置的。")]),e._v(" "),n("h3",{attrs:{id:"_3-资源匹配规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-资源匹配规则"}},[e._v("#")]),e._v(" 3.资源匹配规则")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('scanner.setResourcePattern(componentScan.getString("resourcePattern"));\n')])])]),n("p",[e._v("默认为static final String DEFAULT_RESOURCE_PATTERN = “**/*.class”；\n即扫描传入路径及其子路径下的所有.class文件")]),e._v(" "),n("h3",{attrs:{id:"_4-两个filter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-两个filter"}},[e._v("#")]),e._v(" 4.两个filter")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('for (AnnotationAttributes includeFilterAttributes : componentScan.getAnnotationArray("includeFilters")) {\n            List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(includeFilterAttributes, this.environment,\n                    this.resourceLoader, this.registry);\n            for (TypeFilter typeFilter : typeFilters) {\n                scanner.addIncludeFilter(typeFilter);\n            }\n        }\n        for (AnnotationAttributes excludeFilterAttributes : componentScan.getAnnotationArray("excludeFilters")) {\n            List<TypeFilter> typeFilters = TypeFilterUtils.createTypeFiltersFor(excludeFilterAttributes, this.environment,\n                this.resourceLoader, this.registry);\n            for (TypeFilter typeFilter : typeFilters) {\n                scanner.addExcludeFilter(typeFilter);\n            }\n        }\n')])])]),n("blockquote",[n("p",[e._v("excludeFilter： excludeFilters = {@ComponentScan.Filter (type =\nFilterType.ASSIGNABLE_TYPE,classes = UserService. class)}\n即排除扫描路径下的UserService. class文件，不创建UserService的bean")])]),e._v(" "),n("h3",{attrs:{id:"_5-配置懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-配置懒加载"}},[e._v("#")]),e._v(" 5.配置懒加载")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('boolean lazyInit = componentScan.getBoolean("lazyInit");\n        if (lazyInit) {\n            scanner.getBeanDefinitionDefaults().setLazyInit(true);\n        }\n')])])]),n("h3",{attrs:{id:"_6-扫描包路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-扫描包路径"}},[e._v("#")]),e._v(" 6.扫描包路径")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Set<String> basePackages = new LinkedHashSet<>();\n        String[] basePackagesArray = componentScan.getStringArray("basePackages");//可以传入字符串数组\n        for (String pkg : basePackagesArray) {\n            String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),\n                    ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);//按照规则解析\n            Collections.addAll(basePackages, tokenized);\n        }\n        for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {\n            basePackages.add(ClassUtils.getPackageName(clazz));\n        }\n        //空处理\n        if (basePackages.isEmpty()) {\n            basePackages.add(ClassUtils.getPackageName(declaringClass));\n        }\n')])])]),n("p",[e._v("basePackageClasses属性：将传入类的包名作为路径传入\n空处理：如果未传入任何参数，就将添加该注解的config类的包路径作为扫描路径")]),e._v(" "),n("h3",{attrs:{id:"_7-排除config类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-排除config类"}},[e._v("#")]),e._v(" 7.排除config类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {\n            @Override\n            protected boolean matchClassName(String className) {\n                return declaringClass.equals(className);\n            }\n        });\n")])])]),n("p",[e._v("ExcludeFilter的作用：\n排除添加改注解的config类。因为config类在AnnotationConfigApplicationContext\napplicationContext = new\nAnnotationConfigApplicationContext(AppConfig.class)语句中已经手动加入spring容器")]),e._v(" "),n("h3",{attrs:{id:"_3️⃣-return-scanner-doscan-包路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-return-scanner-doscan-包路径"}},[e._v("#")]),e._v(" 3️⃣：return scanner.doScan(包路径)")]),e._v(" "),n("h3",{attrs:{id:"doscan方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#doscan方法"}},[e._v("#")]),e._v(" doScan方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('protected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    Assert.notEmpty(basePackages, "At least one base package must be specified");\n    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n    for (String basePackage : basePackages) {\n        //真正进行扫描，扫描得到的结果为BeanDefinition\n       Set<BeanDefinition> candidates = 1️⃣findCandidateComponents(basePackage);\n       for (BeanDefinition candidate : candidates) {\n          ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n          candidate.setScope(scopeMetadata.getScopeName());\n          String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n          if (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) {\n             postProcessBeanDefinition(abstractBeanDefinition, beanName);\n          }\n          if (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {\n             AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);\n          }\n\n        //检查是否扫描到相同的BeanDefinition。不同包可能扫描到相同的bean\n          if (5️⃣checkCandidate(beanName, candidate)) {\n             BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n             definitionHolder =\n                   AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n             beanDefinitions.add(definitionHolder);\n             //在spring容器中注册\n             registerBeanDefinition(definitionHolder, this.registry);\n          }\n       }\n    }\n    return beanDefinitions;\n}\n')])])]),n("h3",{attrs:{id:"_5️⃣检测是否存在相同名称的bean-checkcandidate-beanname"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣检测是否存在相同名称的bean-checkcandidate-beanname"}},[e._v("#")]),e._v(" 5️⃣检测是否存在相同名称的bean：checkCandidate(beanName,")]),e._v(" "),n("p",[e._v("candidate)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n    if (!this.registry.containsBeanDefinition(beanName)) {\n       return true;\n    }\n    BeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n    if (originatingDef != null) {\n       existingDef = originatingDef;\n    }\n    if (6️⃣isCompatible(beanDefinition, existingDef)) {  //判断是否兼容\n       return false;\n    }\n    //抛异常，spring容器不能正常启动\n    throw new ConflictingBeanDefinitionException("Annotation-specified bean name \'" + beanName +\n          "\' for bean class [" + beanDefinition.getBeanClassName() + "] conflicts with existing, " +\n          "non-compatible bean definition of same name and class [" + existingDef.getBeanClassName() + "]");\n}\n')])])]),n("h3",{attrs:{id:"_6️⃣判断是否兼容-iscompatible-beandefinition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣判断是否兼容-iscompatible-beandefinition"}},[e._v("#")]),e._v(" 6️⃣判断是否兼容：isCompatible(beanDefinition,")]),e._v(" "),n("p",[e._v("existingDef))")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected boolean isCompatible(BeanDefinition newDef, BeanDefinition existingDef) {\n    //两个类不一样，返回false->导致抛异常\n    return (!(existingDef instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n          (newDef.getSource() != null && newDef.getSource().equals(existingDef.getSource())) ||  // scanned same file twice\n          newDef.equals(existingDef));  // scanned equivalent class twice\n}\n")])])]),n("h3",{attrs:{id:"_1️⃣真正进行扫描的方法-findcandidatecomponents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣真正进行扫描的方法-findcandidatecomponents"}},[e._v("#")]),e._v(" 1️⃣真正进行扫描的方法：findCandidateComponents")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public Set<BeanDefinition> findCandidateComponents(String basePackage) {\n    //7️⃣优化的方法\n    if (this.componentsIndex != null && indexSupportsIncludeFilters()) {\n       return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);\n    }\n    else {\n        //一般执行else\n       return 2️⃣scanCandidateComponents(basePackage);\n    }\n}\n")])])]),n("h3",{attrs:{id:"_7️⃣componentsindex机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣componentsindex机制"}},[e._v("#")]),e._v(" 7️⃣componentsIndex机制")]),e._v(" "),n("p",[e._v("在spring.components文件中指定要成为bean的类。\nspring只会去扫描spring.components文件中指定的类并生成bean。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("com.example.service.Service1=org.springframework.stereotype.Component\n")])])]),n("h3",{attrs:{id:"_2️⃣else的方法-scancandidatecomponents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣else的方法-scancandidatecomponents"}},[e._v("#")]),e._v(" 2️⃣else的方法：scanCandidateComponents")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('private Set<BeanDefinition> scanCandidateComponents(String basePackage) {\n    Set<BeanDefinition> candidates = new LinkedHashSet<>();\n    try {\n       String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n             resolveBasePackage(basePackage) + \'/\' + this.resourcePattern;  //获取完整的路径\n       Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);//获取扫描路径下面的所有.class文件资源\n       boolean traceEnabled = logger.isTraceEnabled();\n       boolean debugEnabled = logger.isDebugEnabled();\n       for (Resource resource : resources) {\n          String filename = resource.getFilename();\n          if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {\n             // Ignore CGLIB-generated classes in the classpath\n             continue;\n          }\n          if (traceEnabled) {\n             logger.trace("Scanning " + resource);\n          }\n          try {\n             MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); //得到类的元数据读取器\n             if (3️⃣isCandidateComponent(metadataReader)) {  //进行第一次判断\n                ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);  //判断完成后生成beanDefinition\n                sbd.setSource(resource);\n                if (4️⃣isCandidateComponent(sbd)) {  //进行第二次判断\n                   if (debugEnabled) {\n                      logger.debug("Identified candidate component class: " + resource);\n                   }\n                   candidates.add(sbd);  //满足条件后加入集合返回\n                }\n                else {\n                   if (debugEnabled) {\n                      logger.debug("Ignored because not a concrete top-level class: " + resource);\n                   }\n                }\n             }\n             else {\n                if (traceEnabled) {\n                   logger.trace("Ignored because not matching any filter: " + resource);\n                }\n             }\n          }\n          catch (FileNotFoundException ex) {\n             if (traceEnabled) {\n                logger.trace("Ignored non-readable " + resource + ": " + ex.getMessage());\n             }\n          }\n          catch (Throwable ex) {\n             throw new BeanDefinitionStoreException(\n                   "Failed to read candidate component class: " + resource, ex);\n          }\n       }\n    }\n    catch (IOException ex) {\n       throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);\n    }\n    return candidates;\n}\n')])])]),n("blockquote",[n("p",[e._v("问题：如何得到扫描路径下的类的metadata？")])]),e._v(" "),n("blockquote",[n("p",[e._v("解决：\n如果使用反射，会在spring容器加载的时候将扫描路径下的所有类加载到jvm中，如果所有这些类中只有极少一部分最终需要成为bean，会造成很大的资源浪费\n使用asm技术，不涉及到类的加载就可以得到类的信息")])]),e._v(" "),n("p",[e._v("3️⃣第一次判断isCandidateComponent(metadataReader)：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n    for (TypeFilter tf : this.excludeFilters) {\n        //如果该类信息与其中一个excludeFilters匹配，则返回false，该类会被排除掉\n       if (tf.match(metadataReader, getMetadataReaderFactory())) {\n          return false;\n       }\n    }\n    for (TypeFilter tf : this.includeFilters) {\n        //至少匹配一个includeFilters，才有可能成为一个bean\n       if (tf.match(metadataReader, getMetadataReaderFactory())) {\n          return isConditionMatch(metadataReader);  //判断有没有@Conditional注解且注解自定义的条件\n\n       }\n    }\n    return false;\n}\n")])])]),n("blockquote",[n("p",[e._v("tf.match(metadataReader, getMetadataReaderFactory()):\n如果没有指定过滤器，则会使用默认过滤器。 默认过滤器在new\nscanner的时候设置：componentScan.getBoolean(“useDefaultFilters”)：默认为true，即使用默认的过滤器\n在scanner的构造方法中，会调用方法设置三个includeFilter（三个注解对应的过滤器，@Component，@Named等）")])]),e._v(" "),n("blockquote",[n("p",[e._v("isConditionMatch(metadataReader)：\n判断有没有满足利用@Conditional注解自定义的条件。\n写一个配置类c实现Condition接口，重写matches方法，\n在其中自定义bean创建的条件。service类中添加@Conditional(c.class)以生效。")])]),e._v(" "),n("p",[e._v("4️⃣第二次判断isCandidateComponent(sbd)：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n    AnnotationMetadata metadata = beanDefinition.getMetadata();\n    return (metadata.isIndependent() && (metadata.isConcrete() ||\n          (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));\n}\n")])])]),n("blockquote",[n("p",[e._v("metadata.isIndependent()：是否为独立类。非静态的内部类不是独立类，非静态的内部类实例化要依赖外部类的对象。非静态的内部类被排除不能生成bean\n静态的内部类实例化不依赖外部类的对象，可以生成bean")])]),e._v(" "),n("blockquote",[n("p",[e._v("metadata.isConcrete()：既不是接口也不是抽象类，返回true。接口和抽象类不能实例化，不能生成bean对象。mybatis中的mapper接口通过动态代理生成代理类的bean对象")])]),e._v(" "),n("blockquote",[n("p",[e._v("metadata.isAbstract() &&\nmetadata.hasAnnotatedMethods(Lookup.class.getName()：是抽象类且类中存在添加了Lookup注解的方法\n，也返回true sd 独立的 且 类中存在添加了Lookup注解的方法 的 抽象类\n生成的bean对象是其代理对象")])]),e._v(" "),n("h2",{attrs:{id:"关于-lookup注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于-lookup注解"}},[e._v("#")]),e._v(" 关于@Lookup注解")]),e._v(" "),n("blockquote",[n("p",[e._v("@Lookup注解的属性需要指定一个bean名字，@Lookup(bean名)")])]),e._v(" "),n("blockquote",[n("p",[e._v("添加了@Lookup注解的方法不会执行方法里的逻辑，只会返回bean名字对应的bean。\n因此返回值类型为bean对象的类型。")])]),e._v(" "),n("blockquote",[n("p",[e._v("问题：假设s1类是singleton，s2类是prototype且s1类中有属性s2。\n1.在s1中用普通方法直接打印多次s2得到的s2对象是同一个吗？\n2.用s1的添加了@Lookup注解的方法获取s2，得到的s2对象是同一个吗？")])]),e._v(" "),n("blockquote",[n("p",[e._v("答案： 1.是同一个。因为s1中的s2属性在创建s1的bean的时候已经注入。\n2.不是同一个。")])])])}),[],!1,null,null,null);n.default=s.exports}}]);